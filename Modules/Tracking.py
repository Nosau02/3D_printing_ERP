"""
FR, EN below:
Module de gestion des devis : 

Ce module affiche la liste des devis enregistr√©s, permet de modifier leur statut (Accept√©, Pay√©, Annul√©),
de g√©n√©rer une facture PDF √† partir d'un devis accept√©, et de visualiser la r√©partition des statuts des devis.
Les donn√©es relatives aux devis sont stock√©es dans le fichier "quote.csv".

Le num√©ro de facture est g√©n√©r√© automatiquement, il est compos√© comme suit:

INV-AAAA-DDMM-Num√©ro s√©quentiel-Initiales du client (ex: INV-2025-3112-000001-JD pour John Doe)

Ce num√©ro est unique et permet de retrouver facilement la facture, il est g√©n√©r√© par la fonction get_number() du module Sequence.py.


La facture est g√©n√©r√©e au format PDF en utilisant la fonction generate_invoice_pdf() du module Invoice_pdf.py.
Cette derni√®re est conforme au droit suisse, un QR code de paiement est inclus.
Elle est sauvegard√©e dans le dossier "Invoices".

Le Logo de l'entrerise doit √™tre plac√© dans le dossier "Data" sous le nom "logo.png".

%============

EN:
Quote management module : 

This module displays the list of registered quotations and allows you to change their status (Accepted, Paid, Cancelled),
generate a PDF invoice from an accepted quote, and view the breakdown of quote statuses.
Quote data is stored in the "quote.csv" file.

The invoice number is generated automatically and is composed as follows:

INV-AAAA-DDMM-Sequential number-Customer initials (e.g. INV-2025-3112-000001-JD for John Doe)

This number is unique and makes it easy to find the invoice. It is generated by the get_number() function in the Sequence.py module.


The invoice is generated in PDF format using the generate_invoice_pdf() function in the Invoice_pdf.py module.
The invoice complies with Swiss law and includes a payment QR code.
It is saved in the "Invoices" folder.

The company logo must be saved in the "Data" folder under the name "logo.png".
"""
from dash import html, dash_table, dcc, callback, Output, Input, State, ctx
import dash_bootstrap_components as dbc
import pandas as pd
import plotly.express as px
from os import path, makedirs
from .Invoice_pdf import generate_invoice_pdf # Imports relatifs ( module dans le m√™me dossier)
from .Sequence import get_number # Imports relatifs ( module dans le m√™me dossier)


# === Configuration de base ===
# Fichiers
QUOTE_FILE = "quote.csv"
PRICE_FILE = "pricing.csv"
CREDITOR_FILE = "creditors.csv"
INVOICE_FOLDER = "Invoices"
FOLDER_PATH = path.split(path.dirname(__file__))[0]  # Dossier parent
DATA_PATH = path.join(FOLDER_PATH, "Data")
QUOTE_PATH = path.join(DATA_PATH, QUOTE_FILE)
PRICE_PATH = path.join(DATA_PATH, PRICE_FILE)
CREDITOR_PATH = path.join(DATA_PATH, CREDITOR_FILE)
INVOICE_PATH = path.join(FOLDER_PATH, INVOICE_FOLDER)
LOGO_PATH = path.join(DATA_PATH, "logo.png")

makedirs(INVOICE_PATH, exist_ok=True)

# Charger les bases de donn√©es de devis, de prix et de cr√©anciers
if path.exists(QUOTE_PATH):
    quote_df = pd.read_csv(QUOTE_PATH)
else:
    quote_df = pd.DataFrame(columns=["Status", "Last name", "First name", "Project", "Total price", "Date", "Address", "City"])

if not path.exists(CREDITOR_PATH):
    raise FileNotFoundError(f"creditor file not found: {CREDITOR_PATH}")

creditor_df = pd.read_csv(CREDITOR_PATH)
pricing_df = pd.read_csv(PRICE_PATH)


# === Layout Function ===
def layout():
    return dbc.Container([
        html.H2("Quote Management", className="text-center text-primary mb-4"),
        dbc.Row([
            dbc.Col([
                dbc.Row([
                    dash_table.DataTable(
                        id='track-quote-table',
                        columns=[{"name": i, "id": i} for i in ["Status", "Last name", "First name", "Project", "Total price", "Date", "Address"]],
                        data=quote_df.to_dict("records"),
                        row_selectable='single',
                        selected_rows=[],
                        page_size=10,
                        style_cell={'textAlign': 'center'},
                        style_table={'height': '400px', 'overflowY': 'auto'}
                    )
                ]),
                dbc.Row([
                    dcc.Graph(id="status-bar", style={"height": "400px"})
                ])
            ], width=7),

            dbc.Col([
                dbc.Row([
                    dbc.Col([dbc.Button("Accept", id="track-btn-accept", color="success", className="mb-2 w-100")]),
                    dbc.Col([dbc.Button("Payment received", id="track-btn-paid", color="info", className="mb-2 w-100")]),
                ]),
                dbc.Row([
                    dbc.Col([dbc.Button("Generate Invoice", id="track-btn-invoice", color="warning", className="mb-2 w-100")]),
                    dbc.Col([
                        dbc.RadioItems(
                            id='track-reciever-radio',
                            options=[{'label': name, 'value': name.lower()} for name in creditor_df['First Name']],
                            inline=True
                        )
                    ])
                ]),
                dbc.Row([
                    dbc.Col([dbc.Button("Cancel", id="track-btn-cancel", color="danger", className="w-100")]),
                    dbc.Col([dbc.Button("Refresh", id="track-btn-refresh", color="secondary", className="mb-2 w-100")]),
                ]),
                html.Div(id='track-confirmation-message', className="text-success mt-3")
            ], width=5)
        ])
    ], fluid=True)


# === Fonctions utilitaires ===
# Mise √† jour de la base de donn√©es mati√®re
def load_quotes():
    if path.exists(QUOTE_PATH):
        return pd.read_csv(QUOTE_PATH)
    return pd.DataFrame(columns=["Status","Last name","First name","Project","Total price","Date","Address","City"])


# === Callbacks ===
def register_callbacks(app):
    # 1) Callback A : g√®re les actions & met √† jour les donn√©es + message
    @callback(
        Output('track-quote-table', 'data'),
        Output('track-confirmation-message', 'children'),
        Input('track-btn-accept', 'n_clicks'),
        Input('track-btn-paid', 'n_clicks'),
        Input('track-btn-invoice', 'n_clicks'),
        Input('track-btn-cancel', 'n_clicks'),
        Input('track-btn-refresh', 'n_clicks'), 
        State('track-quote-table', 'selected_rows'),
        State('track-quote-table', 'data'),
        State('track-reciever-radio', 'value'),
        prevent_initial_call=True
    )


    def handle_actions(n1, n2, n3, n4, n5, selected, data, receiver):
        triggered = ctx.triggered_id

        # Rafra√Æchissement manuel
        if triggered == 'track-btn-refresh':
            quote_df = load_quotes()  # relit le CSV du disque
            message = "üîÑ Data refreshed."

        # Pour les autres actions, on part de l'√©tat actuel
        else:
            quote_df = pd.DataFrame(data) if data else quote_df.copy()
            message = ""

        # Si un bouton a √©t√© cliqu√© mais aucune s√©lection :
        if triggered in ('track-btn-accept', 'track-btn-paid', 'track-btn-invoice', 'track-btn-cancel') and not selected:
            return quote_df.to_dict("records"), "‚ö†Ô∏è Please select a row."

        # Devis accept√©
        if triggered == 'track-btn-accept':
            idx = selected[0]
            quote_df.at[idx, "Status"] = "Accepted"
            message = "‚úÖ Quote accepted."

        # Payement re√ßu
        elif triggered == 'track-btn-paid':
            idx = selected[0]
            quote_df.at[idx, "Status"] = "Paid"
            message = "‚úÖ Payment confirmed."

        # Devis annul√©
        elif triggered == 'track-btn-cancel':
            idx = selected[0]
            quote_df.at[idx, "Status"] = "Cancelled"
            message = "‚ùå Quote cancelled."

        # G√©n√©ration de la facture PDF
        elif triggered == 'track-btn-invoice':
            # S√©lection du devis par l'index
            idx = selected[0]

            # V√©rifier la s√©lection du cr√©ancier
            if not receiver:
                return quote_df.to_dict("records"), "‚ö†Ô∏è Please select a creditor (receiver) before generating the invoice."

            # Rechercher du cr√©ancier s√©lectionn√© dans la base de donn√©e
            mask = creditor_df['First Name'].str.lower() == receiver
            if not mask.any():
                return quote_df.to_dict("records"), "‚ö†Ô∏è Selected creditor not found in creditor list."

            # R√©cup√©rer les infos cr√©ancier
            row = creditor_df.loc[mask].iloc[0]
            creditor = {
                "name": f"{row['First Name']} {row['Last Name']}",
                "line1": f"{row['Adresse']}",
                "line2": f"{row['NPA and City']}",
                "country": f"{row['Country']}",
            }
            iban = row['IBAN']

            # R√©cup√©rer les infos d√©biteur depuis la base de donn√©e devis
            last_name = quote_df.at[idx, "Last name"]
            first_name = quote_df.at[idx, "First name"]
            address = quote_df.at[idx, "Address"]
            city = quote_df.at[idx, "City"]
            debtor = {"name": f"{first_name} {last_name}", "line1": address, "line2": city, "country": "CH"}

            # Cr√©er le tableau des items de la facture
            items = pd.DataFrame({
                "Description": [    f'Conception',
                                    f'Impression',   
                                    f'Manutention',
                                    f'Materiaux ({quote_df.at[idx,"Material"]})'],
                "Quantity": [       quote_df.at[idx,"Design hours"],
                                    quote_df.at[idx,"Printing hours"],   
                                    quote_df.at[idx,"Handling hours"],
                                    quote_df.at[idx,"Mass (g)"] / 1000],  # Convert g to kg                                        
                "UnitPrice": [      pricing_df["Design"].iloc[0],
                                    pricing_df["Printing"].iloc[0],   
                                    pricing_df["Handeling"].iloc[0],
                                    quote_df.at[idx,"Price per kg"] * pricing_df["Material markup"].iloc[0]],
                "Unit": [           "h", "h", "h", "kg"], 
                "Markdown": [      quote_df.at[idx,"Discount CHF"],0,0,0]
            }) 

            # G√©n√©reration de l'ID de la facture
            invoice_id= get_number("INV", f"{first_name} {last_name}")

            # G√©n√©ration du PDF
            out = generate_invoice_pdf(
                creditor=creditor,
                debtor=debtor,
                items_df=items,
                quote_num=quote_df.at[idx,"ID"],
                invoice_num=invoice_id,
                output_folder= INVOICE_PATH,
                iban=iban,
                currency="CHF",
                payment_terms="Paiement √† 30 jours net",
                logo_path = LOGO_PATH if path.exists(LOGO_PATH) else None
            )
            # Mettre √† jour le statut du devis et message de confirmation
            quote_df.at[idx, "Status"] = "Invoiced"
            message = f"üìÑ Invoice generated: {out}"


        # Sauvegarde des donn√©es (pour tous les cas modifiant quote_df)
        quote_df.to_csv(QUOTE_PATH, index=False)
        return quote_df.to_dict("records"), message


    # 2) Callback B : construit le graphe √† partir des donn√©es du tableau
    @callback(
        Output('status-bar', 'figure'),
        Input('track-quote-table', 'data'),
        prevent_initial_call=False
    )
    def update_bar(data):
        quote_df = pd.DataFrame(data) if data else pd.DataFrame(columns=["Status"])
        if quote_df.empty or "Status" not in quote_df.columns:
            return px.bar(title="Quote Status Overview", template="plotly")

        status_counts = (
            quote_df["Status"]
            .fillna("Unknown")
            .value_counts(dropna=False)
            .rename_axis("Status")
            .reset_index(name="Count")
        )

        # === correspondance Status -> couleurs Bootstrap ===
        color_map = {
            "Accepted": "#198754",   # vert (btn-success)
            "Paid": "#0dcaf0",       # bleu clair (btn-info)
            "Invoiced": "#ffc107",   # jaune (btn-warning)
            "Cancelled": "#dc3545",  # rouge (btn-danger)
            "Issued": "#6c757d",     # gris (btn-secondary, si besoin)
            "Unknown": "#adb5bd"     # gris clair
        }

        fig = px.bar(
            status_counts,
            x="Status",
            y="Count",
            title="Quote Status Overview",
            color="Status",
            color_discrete_map=color_map,
            text="Count",
            template="plotly"
        )

        fig.update_traces(textposition="outside", cliponaxis=False)
        fig.update_layout(yaxis={"rangemode": "tozero"})

        return fig
   

# === Ex√©cution en standalone ===

if __name__ == '__main__':
    from dash import Dash
    app = Dash(__name__, external_stylesheets=[dbc.themes.CERULEAN])
    app.layout = layout()
    register_callbacks(app)
    app.run(debug=True)